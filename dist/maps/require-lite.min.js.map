{"version":3,"sources":["require-lite.js"],"names":["define","require","init","_get","Function","CACHE_TOKEN","name","definitions","CACHED","defined","DEFINED","pending","PENDING","clear","initDefinition","args","arguments","val","apply","DEFINITIONS_TOKEN","resolveModule","initHandler","i","len","dependencyName","deps","length","ignoreWarnings","console","warn","hasOwnProperty","exports","REQUIRE","push","EXPORTS","undefined","returnVal","DEFAULT","resolve","fn","timer","Error","clearInterval","setTimeout","modules","handler","clearTimeout","toString","ready","readyHandler"],"mappings":"AAAA,GAAAA,QAAAC,SACA,WAMA,QAAAC,KACAC,EAAAC,SAAAC,GAAAD,SAAAC,IAAA,SAAAC,GAIA,MAHAH,GAAAG,KACAH,EAAAG,OAEAH,EAAAG,IAEAC,EAAAJ,EAAAK,GACAC,EAAAN,EAAAO,GACAC,EAAAR,EAAAS,GAEA,QAAAC,WACAT,UAAAC,SACAE,SACAE,SACAE,GACAT,IAKA,QAAAY,GAAAR,GACA,IAAAG,EAAAH,GAAA,CACA,GAAAS,GAAAC,UACAC,EAAAF,EAAA,EACA,mBAAAE,GAEAR,EAAAH,GAAAW,EAAAC,OAAAZ,KAAAA,KAKAC,EAAAD,GAAAS,EAAA,GACAR,EAAAD,GAAAa,GAAAF,IAKA,QAAAG,GAAAd,EAAAe,GACAV,EAAAL,IAAA,CACA,IAEAgB,GAAAC,EACAC,EAHAC,EAAAJ,EAAAF,GACAJ,IAGA,IAAAU,EAEA,IADAF,EAAAE,EAAAC,OACAJ,EAAA,EAAAC,EAAAD,EAAAA,IACAE,EAAAC,EAAAH,GAEAX,EAAAa,GACAvB,QAAA0B,gBACAC,QAAAC,KAAA,iCAAAvB,EAAA,UAAAkB,GAGAjB,EAAAiB,IACAJ,EAAAI,EAAAjB,EAAAiB,UAEAjB,GAAAiB,EAGA,KAAAf,EAAAqB,eAAAxB,GAAA,CACA,GAAAyB,EAEA,KAAAT,EAAA,EAAAC,EAAAD,EAAAA,IACAE,EAAAC,EAAAH,GACAE,IAAAQ,EACAjB,EAAAkB,KAAAhC,SAEAuB,IAAAU,GACAH,KACAhB,EAAAkB,KAAAF,IAEAtB,EAAAqB,eAAAN,GACAT,EAAAkB,KAAAxB,EAAAe,IAEAvB,QAAA0B,iBACAZ,EAAAkB,KAAAE,QACAP,QAAAC,KAAA,WAAAvB,EAAA,eAAAkB,EAAA,uBAGA,IAAAY,GAAAf,EAAAH,OAAAZ,KAAAA,GAAAS,EACAgB,GACAA,EAAAD,eAAAO,GACA5B,EAAAH,GAAAyB,EAAAM,GAGA5B,EAAAH,GAAAyB,EAIAtB,EAAAH,GAAA8B,QAGAzB,GAAAL,GAEA,QAAAgC,KACA,IAAA,GAAAhC,KAAAC,GACA,GAAAA,EAAAuB,eAAAxB,GAAA,CACA,GAAAiC,GAAAhC,EAAAD,SACAC,GAAAD,GACAc,EAAAd,EAAAiC,GAGA9B,EAAA,MACAA,EAAA,OA7GA,GAAAN,GAAAM,EAAAE,EAAAJ,EAAAiC,EAAA,EACAnC,EAAA,IAAAc,EAAA,IAAAa,EAAA,UAAAE,EAAA,UAAAG,EAAA,UAAA7B,EAAA,IAAAE,EAAA,IAAAE,EAAA,GA+GAZ,QAAA,SAAAM,EAAAmB,EAAAJ,GAEA,GADA,SAAAI,IAAAA,MACA,gBAAAnB,GACA,KAAA,IAAAmC,OAAA,uCAEA3B,GAAAI,OAAAZ,KAAAA,GAAAU,WACA0B,cAAAF,GACAG,WAAAL,IAEArC,QAAA,SAAA2C,EAAAC,GAGA,GAFAC,aAAAN,GACAF,KACAO,EAAA,CACA,GAAA,gBAAAD,IAAAA,EAAAlB,OAAA,EACA,KAAA,IAAAe,OAAA,6BAEA,IAAAnC,GAAAsC,EAAAG,UACA,OAAAtC,GAAAH,GAEA,GAAAS,KACA,iBAAA6B,KACAA,GAAAA,GAGA,KAAA,GADArB,GAAAqB,EAAAlB,OACAJ,EAAA,EAAAC,EAAAD,EAAAA,IACAP,EAAAkB,KAAAxB,EAAAmC,EAAAtB,IAEAuB,GAAA3B,MAAA,KAAAH,IAEAd,QAAAY,MAAAA,EACAZ,QAAA0B,gBAAA,EACA1B,QAAA+C,MAAA,SAAAC,GACAxC,EAAA,KAAAwC,GAEA/C","file":"require-lite.min.js","sourcesContent":["var define, require;\n(function () {\n    var _get, defined, pending, definitions, timer = 0;\n    var CACHE_TOKEN = '~', DEFINITIONS_TOKEN = '.', REQUIRE = 'require', EXPORTS = 'exports', DEFAULT = 'default', CACHED = 'c', DEFINED = 'd', PENDING = 'p';\n    /**\n     * Sets and Gets cache, defined, and pending items in a private internal cache\n     */\n    function init() {\n        _get = Function[CACHE_TOKEN] = Function[CACHE_TOKEN] || function (name) {\n            if (!_get[name]) {\n                _get[name] = {};\n            }\n            return _get[name];\n        };\n        definitions = _get(CACHED); // these are items that have been initialized and permanently cached\n        defined = _get(DEFINED); // these are items that have been defined but have not been initialized\n        pending = _get(PENDING); // these are items that have been initialized but have deps that need initialized before done\n    }\n    function clear() {\n        delete Function[CACHE_TOKEN];\n        delete definitions;\n        delete defined;\n        delete pending;\n        init();\n    }\n    /**\n     * Initializes\n     */\n    function initDefinition(name) {\n        if (!defined[name]) {\n            var args = arguments;\n            var val = args[1];\n            if (typeof val === 'function') {\n                // ex. define('myFunc', function(){...});\n                defined[name] = val.apply({ name: name }); // invoke immediately and assign to defined\n            }\n            else {\n                // store in a temporary definitions until all definitions have been processed\n                // ex. define('myFunc', ['toBoolean'], function(toBoolean){...})\n                definitions[name] = args[2]; // skip array and assign funtion to cached name\n                definitions[name][DEFINITIONS_TOKEN] = val; // assign dependencies to definitions on function itself\n            }\n        }\n    }\n    ;\n    function resolveModule(name, initHandler) {\n        pending[name] = true; // mark this definition as pending\n        var deps = initHandler[DEFINITIONS_TOKEN]; // get any dependencies required by definition\n        var args = [];\n        var i, len;\n        var dependencyName;\n        if (deps) {\n            len = deps.length;\n            for (i = 0; i < len; i++) {\n                dependencyName = deps[i];\n                // if (definitions[dependencyName]) {\n                if (pending[dependencyName]) {\n                    if (!require.ignoreWarnings) {\n                        console.warn('Recursive dependency between \"' + name + '\" and \"' + dependencyName);\n                    }\n                }\n                else if (definitions[dependencyName]) {\n                    resolveModule(dependencyName, definitions[dependencyName]);\n                }\n                delete definitions[dependencyName];\n            }\n        }\n        if (!defined.hasOwnProperty(name)) {\n            var exports;\n            var module;\n            for (i = 0; i < len; i++) {\n                dependencyName = deps[i]; // get the dependency name\n                if (dependencyName === REQUIRE) {\n                    args.push(require);\n                }\n                else if (dependencyName === EXPORTS) {\n                    exports = {};\n                    args.push(exports);\n                }\n                else if (defined.hasOwnProperty(dependencyName)) {\n                    args.push(defined[dependencyName]); // this will push an item even if it is undefined\n                }\n                else if (!require.ignoreWarnings) {\n                    args.push(undefined);\n                    console.warn('Module \"' + name + '\" requires \"' + dependencyName + '\", but is undefined');\n                }\n            }\n            var returnVal = initHandler.apply({ name: name }, args); // call the function and assign return value onto defined list\n            if (exports) {\n                if (exports.hasOwnProperty(DEFAULT)) {\n                    defined[name] = exports[DEFAULT];\n                }\n                else {\n                    defined[name] = exports;\n                }\n            }\n            else {\n                defined[name] = returnVal;\n            }\n        }\n        delete pending[name]; // permanently remove pending item\n    }\n    function resolve() {\n        for (var name in definitions) {\n            if (definitions.hasOwnProperty(name)) {\n                var fn = definitions[name];\n                delete definitions[name];\n                resolveModule(name, fn);\n            }\n        }\n        if (defined['~']) {\n            defined['~']();\n        }\n    }\n    define = function (name, deps, initHandler) {\n        if (deps === void 0) { deps = []; }\n        if (typeof name !== 'string') {\n            throw new Error('Property \"name\" requires type string');\n        }\n        initDefinition.apply({ name: name }, arguments);\n        clearInterval(timer);\n        setTimeout(resolve);\n    };\n    require = function (modules, handler) {\n        clearTimeout(timer);\n        resolve();\n        if (!handler) {\n            if (typeof modules !== 'string' && modules.length > 1) {\n                throw new Error('Callback function required');\n            }\n            var name = modules.toString();\n            return defined[name];\n        }\n        var args = [];\n        if (typeof modules === 'string') {\n            modules = [modules];\n        }\n        var len = modules.length;\n        for (var i = 0; i < len; i++) {\n            args.push(defined[modules[i]]);\n        }\n        handler.apply(null, args);\n    };\n    require.clear = clear;\n    require.ignoreWarnings = false;\n    require.ready = function (readyHandler) {\n        defined['~'] = readyHandler;\n    };\n    init();\n}());\n//# sourceMappingURL=require-lite.js.map"],"sourceRoot":"/source/"}