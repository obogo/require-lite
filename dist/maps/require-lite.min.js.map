{"version":3,"sources":["require-lite.js"],"names":["define","require","requireWorker","init","_get","Function","CACHE_TOKEN","name","raw","RAW","definitions","CACHED","defined","DEFINED","pending","PENDING","clear","initDefinition","args","arguments","val","apply","DEFINITIONS_TOKEN","resolveModule","initHandler","i","len","dependencyName","deps","length","ignoreWarnings","console","warn","hasOwnProperty","exports","REQUIRE","push","EXPORTS","undefined","returnVal","DEFAULT","resolve","name_1","fn","e","callback","timer","Error","message","clearInterval","setTimeout","modules","handler","clearTimeout","name_2","toString","workerTemplate","fnStr","replace","m","g1","g2","j","dep","str","used","join","ready","readyHandler","errorHandler"],"mappings":"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","file":"../require-lite.min.js","sourcesContent":["var define, require;\n(function () {\n    var requireWorker = function () {\n        var _get, defined, pending, definitions, timer = 0, raw;\n        var CACHE_TOKEN = '~', DEFINITIONS_TOKEN = '.', REQUIRE = 'require', EXPORTS = 'exports', DEFAULT = 'default', CACHED = 'c', DEFINED = 'd', PENDING = 'p', RAW = 'r';\n        /**\n         * Sets and Gets cache, defined, and pending items in a private internal cache\n         */\n        function init() {\n            _get = Function[CACHE_TOKEN] = Function[CACHE_TOKEN] || function (name) {\n                if (!_get[name]) {\n                    _get[name] = {};\n                }\n                return _get[name];\n            };\n            raw = _get(RAW);\n            definitions = _get(CACHED); // these are items that have been initialized and permanently cached\n            defined = _get(DEFINED); // these are items that have been defined but have not been initialized\n            pending = _get(PENDING); // these are items that have been initialized but have deps that need initialized before done\n        }\n        function clear() {\n            delete Function[CACHE_TOKEN];\n            delete definitions;\n            delete defined;\n            delete pending;\n            init();\n        }\n        /**\n         * Initializes\n         */\n        function initDefinition(name) {\n            if (!defined[name]) {\n                var args = arguments;\n                var val = args[1];\n                if (typeof val === 'function') {\n                    // ex. define('myFunc', function(){...});\n                    defined[name] = val.apply({ name: name }); // invoke immediately and assign to defined\n                }\n                else {\n                    // store in a temporary definitions until all definitions have been processed\n                    // ex. define('myFunc', ['toBoolean'], function(toBoolean){...})\n                    definitions[name] = args[2]; // skip array and assign funtion to cached name\n                    definitions[name][DEFINITIONS_TOKEN] = val; // assign dependencies to definitions on function itself\n                }\n            }\n        }\n        function resolveModule(name, initHandler) {\n            pending[name] = true; // mark this definition as pending\n            var deps = initHandler[DEFINITIONS_TOKEN]; // get any dependencies required by definition\n            var args = [];\n            var i, len;\n            var dependencyName;\n            if (deps) {\n                len = deps.length;\n                for (i = 0; i < len; i++) {\n                    dependencyName = deps[i];\n                    // if (definitions[dependencyName]) {\n                    if (pending[dependencyName]) {\n                        if (!require.ignoreWarnings) {\n                            console.warn('Recursive dependency between \"' + name + '\" and \"' + dependencyName);\n                        }\n                    }\n                    else if (definitions[dependencyName]) {\n                        resolveModule(dependencyName, definitions[dependencyName]);\n                    }\n                    delete definitions[dependencyName];\n                }\n            }\n            if (!defined.hasOwnProperty(name)) {\n                var exports = void 0;\n                var module = void 0;\n                for (i = 0; i < len; i++) {\n                    dependencyName = deps[i]; // get the dependency name\n                    if (dependencyName === REQUIRE) {\n                        args.push(require);\n                    }\n                    else if (dependencyName === EXPORTS) {\n                        exports = {};\n                        args.push(exports);\n                    }\n                    else if (defined.hasOwnProperty(dependencyName)) {\n                        args.push(defined[dependencyName]); // this will push an item even if it is undefined\n                    }\n                    else if (!require.ignoreWarnings) {\n                        args.push(undefined);\n                        console.warn('Module \"' + name + '\" requires \"' + dependencyName + '\", but is undefined');\n                    }\n                }\n                var returnVal = initHandler.apply({ name: name }, args); // call the function and assign return value onto defined list\n                if (exports) {\n                    if (exports.hasOwnProperty(DEFAULT)) {\n                        defined[name] = exports[DEFAULT];\n                    }\n                    else {\n                        defined[name] = exports;\n                    }\n                }\n                else {\n                    defined[name] = returnVal;\n                }\n            }\n            delete pending[name]; // permanently remove pending item\n        }\n        function resolve() {\n            for (var name_1 in definitions) {\n                if (definitions.hasOwnProperty(name_1)) {\n                    var fn = definitions[name_1];\n                    delete definitions[name_1];\n                    try {\n                        resolveModule(name_1, fn);\n                    }\n                    catch (e) {\n                    }\n                }\n            }\n            var callback = defined[CACHE_TOKEN];\n            if (callback) {\n                delete defined[CACHE_TOKEN];\n                callback();\n            }\n        }\n        define = function (name, deps, initHandler) {\n            if (deps === void 0) { deps = []; }\n            if (typeof name !== 'string') {\n                throw new Error('Property \"name\" requires type string');\n            }\n            try {\n                raw[name] = { name: name, deps: deps, fn: initHandler };\n                initDefinition.apply({ name: name }, arguments);\n            }\n            catch (e) {\n                throw new Error('ModuleError in \"' + name + '\": ' + e.message);\n            }\n            clearInterval(timer);\n            setTimeout(resolve);\n        };\n        require = function (modules, handler) {\n            clearTimeout(timer);\n            resolve();\n            if (!handler) {\n                if (typeof modules !== 'string' && modules.length > 1) {\n                    throw new Error('Callback function required');\n                }\n                var name_2 = modules.toString();\n                return defined[name_2];\n            }\n            var args = [];\n            if (typeof modules === 'string') {\n                modules = [modules];\n            }\n            var len = modules.length;\n            for (var i = 0; i < len; i++) {\n                args.push(defined[modules[i]]);\n            }\n            handler.apply(null, args);\n        };\n        require.clear = clear;\n        require.ignoreWarnings = false;\n        require.resolve = resolve;\n        require.workerTemplate = function (fn) {\n            var fnStr = fn.toString();\n            var deps = [];\n            fnStr.replace(/\\W+require\\((\"|')(.*?)\\1\\)/g, function (m, g1, g2) {\n                deps.push(g2);\n            });\n            var str = 'function(e) {\\nvar define, require;\\n(' + requireWorker + ')();\\n', i, j, dep, used = {};\n            deps = deps || [];\n            for (i = 0; i < deps.length; i += 1) {\n                dep = raw[deps[i]];\n                str += '    define(\"' + dep.name + '\", ' + (dep.deps.join ? '[\"' + dep.deps.join('\",\"') + '\"], ' + dep.fn : dep.deps) + ');\\n';\n                for (j = 0; j < dep.deps.length; j += 1) {\n                    if (!used[dep.deps[j]]) {\n                        used[dep.deps[j]] = true;\n                        deps.push(dep.deps[j]);\n                    }\n                }\n            }\n            return fnStr.replace(/^.*?\\{/, str);\n        };\n        require.ready = function (readyHandler, errorHandler) {\n            defined[CACHE_TOKEN] = readyHandler;\n            defined[DEFINITIONS_TOKEN] = errorHandler;\n        };\n        init();\n    };\n    return requireWorker();\n})();\n"]}